# TD3: Glitch

## Intro

Aujourd'hui on va faire glitcher une image ! Puis en faire une animation !

![](./img/Glitch.gif)



## PARTIE 1

Pour comprendre le principe du glitch art sur des images, on va commencer par corrompre un fichier manuellement et voir les r√©sultats.
Ainsi, on pourra comprendre et automatiser le processus pour le faire √† la cha√Æne :)


### a ¬∑ T√©l√©charger un JPEG

(PROTIP: les images t√©l√©charg√©es depuis Facebook glitchent PARTICULI√àREMENT BIEN, probablement parce qu'elles ont une recompression bien crade)


### b ¬∑ Ouvrez-le en utilisant un √©diteur hexad√©cimal

Pour cet exemple, je vous conseille d'utiliser un √©diteur tel que l'app Web [https://hexed.it](https://hexed.it/).

![](./img/Pasted-image-20231119164220.png)


### c ¬∑ Allez en plein milieu du fichier, s√©lectionnez quelques lignes et supprimez-les avec la touche {kbd}`Suppr`

![](./img/ezgif-4-f0e60664fe.gif)


### d ¬∑ Sauvegardez (avec le bouton `Exporter`)


### e ¬∑ Ouvrez l'image export√©e


### f ¬∑ Recommencez

Revenez √† [(c)](#c--allez-en-plein-milieu-du-fichier-s√©lectionnez-quelques-lignes-et-supprimez-les-avec-la-touche) jusqu'√† obtenir des r√©sultats perceptibles.


### Conclusion de la partie 1

Dans ce TD, nous allons faire un script afin de produire cet effet automatiquement plusieurs fois d'affil√©e, et en faire une animation !



## PARTIE 2

### 1 ¬∑ Ouvrir le fichier

üëâ Ouvre le fichier image √† glitcher en **mode binaire**, au moyen de la fonction `open()` en mode `rb`.

:::{admonition} Ouverture d'un fichier en mode binaire
:class: tip, dropdown
Pour ouvrir un fichier en mode binaire, on utilise la fonction int√©gr√©e √† Python `open()`.

```python
fichier = open("C:/Chemin/Vers/Le/Fichier.jpg", "rb")
```

Cette fonction prend 2 param√®tres :
* un premier param√®tre correspondant au chemin vers le fichier √† ouvrir
* le mode d'ouverture du fichier : ici `rb`. 
  `r` correspond √† ***read***, donc lecture, et `b` √† ***binaire*** :)

Elle renvoie un [**objet**](./cours.md#objet) pointant vers le fichier, objet qui poss√®de tous les m√©canismes permettant de lire et √©crire le fichier ! (apr√®s l'avoir ouvert)
:::

:::{note}
Pour ouvrir un fichier texte normal, le mode `"r"` suffirait. Mais comme on veut p√©ter des trucs √† l'√©chelle de l'octet, on pr√©f√®rera le mode *binaire*.

L'autre souci majeur pour notre cas, est que le mode de lecture simple tente de d√©coder le contenu du fichier en partant du principe qu'il s'agisse d'un texte fait de caract√®res lisible par les humains, et encod√©s en tant que tel.

Cela nous pose particuli√®rement souci ici, puisque les donn√©es des images que l'on souhaite lire et alt√©rer ne sont pour la plupart pas des caract√®res encod√©s interpr√©tables par l'humain.

Ainsi, dans ce mode, la m√©thode `.read()` √©chouera √† interpr√©ter certaines parties du fichier et fera crasher le programme.

tl;dr:
* mode *texte* `'r'` => humains (fichier texte, configuration, documentation...)
* mode *binaire* `'rb'` => machines (image, vid√©o, zip, ex√©cutable...)
:::


### 2 ¬∑ Lire et r√©cup√©rer le contenu du fichier

üëâ Lire le fichier afin de stocker son contenu dans une variable gr√¢ce √† la m√©thode `.read()` de l'objet pointeur de fichier que l'on a cr√©√© en [(1)](#1--ouvrir-le-fichier), retourn√© par l'appel √† la fonction `open`.

:::{admonition} Lecture du contenu d'un fichier
:class: tip, dropdown
Pour r√©cup√©rer le contenu d'un fichier, on utilise la m√©thode `.read()` de l'objet pointant vers le fichier que l'on a ouvert plus haut.
```python
contenu_du_fichier_brut = fichier.read()
```

Cette m√©thode lira notre fichier/image et retournera son contenu.
:::


üëâ Une fois le travail sur le fichier termin√©, fermez le fichier afin de le rendre disponible au reste de votre OS et de vos applications.

Cela √©vite le fameux *"Ce fichier est d√©j√† utilis√© par un autre processus"*.


:::{admonition} Fermeture d'un fichier
:class: tip, dropdown
Pour fermer un fichier et ainsi laisser le reste du monde y acc√©der de nouveau, vous pouvez utiliser la m√©thode `.close()` de l'objet pointeur de fichier que vous avez r√©cup√©r√© en [(1)](#1--ouvrir-le-fichier).

```python
fichier.close()
```

Ce n'est pas _obligatoire_, mais il s'agit d'une bonne pratique de programmation.
:::


### 3 ¬∑ Transformation du contenu r√©cup√©r√© en *liste*

La valeur retourn√©e par `.read()` en mode binaire est une valeur de type *bytearray*. Il s'agit litt√©ralement d'un *tableau d'octets*, √† savoir le contenu brut de notre fichier stock√© octet par octet sous la forme d'une sorte de *liste*, et non interpr√©t√© par Python.

:::{admonition} D√©finition d'un octet
:class: note, dropdown

Un *octet* est l'unit√© de stockage de donn√©es informatiques la plus petite, et constitu√©e de *8 bits*, 1 bit correspondant √† l'unit√© stockant le fameux 0 ou 1.

D'o√π **OCT**et... octo... huit... tu l'as?
:::

Le probl√®me du *bytearray*, bien qu'il soit tr√®s similiaire √† une [liste](./cours.md#listes), est que l'on ne peut √©diter son contenu case par case. Ce qui est bien dommage puisque dans le cadre de notre corruption de donn√©es, c'est exactement ce que l'on souhaiterait faire...

Il va donc falloir que l'on [convertisse](./cours.md#casting) (ou *caste*) cette variable de type _bytearray_ en une _[liste](./cours.md#listes)_, un type de valeur bien plus classique que nous manipulons depuis notre premier cours. Et qui est donc tout √† fait √©ditable, case par case.

üëâ Convertissez la variable de type *bytearray* `contenu_du_fichier_brut` en une liste stock√©e dans une variable nomm√©e `contenu_du_fichier`.

:::{admonition} Conversion ou *casting* d'une valeur
:class: tip, dropdown
Pour convertir la valeur d'une variable d'un type √† l'autre, nous pouvons [caster](./cours.md#casting) notre variable de type `bytearray` afin de recopier les valeurs contenu de chacunes de ses cases dans une nouvelle variable `list`.

En Python, cela correspond √† appeler une fonction correspondant au type de destination d√©sir√©, avec comme unique param√®tre la variable ou la valeur √† convertir.

Ici, pour convertir une variable `contenu_du_fichier_brut` en *list*, on √©crirait :

```python
contenu_du_fichier = list(contenu_du_fichier_brut)
```

D'ailleurs, vous pourrez tout √† fait utiliser ce proc√©d√© pour, √† l'inverse, convertir une variable de type *list* en *bytearray*, en √©crivant `bytearray(votre_variable_a_convertir)` !
:::

:::{admonition} FYI EXPLICATION BONUS : Quelques explication non exhaustives sur les diff√©rences entre bytearray et liste
:class: info, dropdown

*‚ö†Ô∏è C'est vraiment giga bonus donc si vous comprenez pas tout c'est pas grave du tout (mais h√©sitez pas √† me questionner si le sujet vous int√©resse)*

En gros :

* Un *byte* est un *octet*, soit une unit√© d'information compos√©e de 8 bits, soit un nombre qui peut aller de 0 √† 255.
  
* Un *bytearray* est un tableau d'*octets* : il y a donc un *octet* par case. Il ne permet de ne stocker rien d'autre qu'un *octet*, contrairement √† une *liste* qui permet de stocker tout et n'importe quoi.
  
* Un *byte/octet* peut √™tre repr√©sent√© par un code *hexad√©cimal*, permettant de repr√©senter un nombre de 0 √† 255 suivant une num√©rotation en base 16 allant de 00 √† FF. 
  (base 16 √ßa veut dire qu'au lieu de compter 0 1 2 3 4 5 6 7 8 9 10 comme en base 10, on peut compter de 0 √† 16 en comptant 0 1 2 3 4 5 6 7 8 9 A B C D E F. Ca veut dire qu'avec 1 chiffre hexa on peut compter jusqu'√† 16, et en mettant 2 chiffres hexa c√¥te √† c√¥te on peut compter jusqu'√† 255)
  
* Un *bytearray* est fait pour √™tre une structure de donn√©es brute pouvait √™tre interpr√©t√©e suivant diff√©rents encodages, ceux-ci d√©finissant quel enchainement d'octet correspond √† quel caract√®re. C'est un de ses usages sp√©cifiques principaux, et c'est pour cette raison qu'il est aussi peu flexible. Contrairement aux [listes](./cours.md#listes).


Vous pouvez avoir un aper√ßu dans l'image ci-dessous des diff√©rences entre respectivement :

* l'information brute de ce qui est stock√© dans un fichier, octet par octet (suivant une notation hexad√©cimale)
* les m√™mes informations stock√©es dans un *bytearray*, quand on `print` ce dernier
* la liste correspondant au *bytearray* apr√®s qu'on l'ait *[converti/cast√©](./cours.md#casting)*, et que chaque octet se retrouve ainsi individuellement plac√© dans cette liste sous forme de nombres entiers de 0 √† 255.
 
  ![](./img/Pasted-image-20231120014211.png)

**NOTE:**
: Dans cette repr√©sentation du *bytearray*, les *octets* comportant potentiellement un caract√®re affichable sont montr√©s (les caract√®res affichables √©tant par exemple les caract√®res alphanum√©riques, sp√©ciaux, etc), mais le contenu du reste des octets non interpr√©tables sont affich√©s sous forme de code hexad√©cimal, avec le petit pr√©fixe `\x` suivi de leur valeur. (ce pr√©fixe veut dire en gros *"hey il va y avoir un code hexa juste apr√®s (mais jsp c koi, faites vos recherches)"*)
:::

### 4 ¬∑ Bord√©lisation

#### a) Localisation d'une case random

On va maintenant localiser une case al√©atoire de notre tableau `contenu_du_fichier`, afin de changer sa valeur (et commencer √† foutre le bordel dans notre image du coup).

üëâ Tirez un num√©ro de case au hasard de votre tableau `contenu_du_fichier`.

:::{tip}
Le contenu de notre fichier √©tant maintenant stock√© dans une liste, on peut donc connaitre la taille de cette liste avec la fonction `len()`, et choisir une case al√©atoire en utilisant notre vieil ami `random.randint()` (voir le [TD2](./td02.md#1--cr√©e-une-liste-et-remplis-l√†-de-100-nombres-al√©atoires)).
:::

#### b) Changement de la valeur de la case

üëâ Une fois un num√©ro de case al√©atoire du tableau choisi, changer sa valeur par un **nombre entier** entre `0` et `255`.

Si t'es pas inspir√©, mets lui juste `0`.

:::{admonition} RAPPEL : Comment acc√©der √† une case particuli√®re d'une liste
:class: tip, dropdown
Pour acc√©der √† la case d'une liste, on √©crit le num√©ro de case d√©sir√© entre crochets `[]` suivant directement le nom de la variable contenant la liste √† acc√©der.

**Exemple 1** : remplacer le contenu de la case 3 (la 4e) de la liste `tableau` par la valeur num√©rique `68`
```python
tableau[3] = 68
```

**Exemple 2** : lire le contenu de la case 0 (la toute premi√®re) de la liste `tableau` et stockage dans une variable
```python
contenu_premiere_case = tableau[0]
```
:::


### 5 ¬∑ Retransformation de la liste en *bytearray*

Maintenant que l'on a gliss√© cette petite valeur intruse et coquine en plein milieu de notre fichier, on va pouvoir √©crire notre image corrompue afin de constater les r√©sultats de la corruption.

On va cependant devoir repasser notre liste d'octets en *bytearray* afin de pouvoir l'√©crire en *mode binaire* √† la section suivante.

üëâ Reconvertir `contenu_du_fichier` en *bytearray*, et stocker le r√©sultat de cette conversion dans une variable qu'on pourrait appeler `nouveau_contenu_du_fichier_brut` par exemple.

:::{tip}
(Re)voir le tip du [(3)](#3--transformation-du-contenu-r√©cup√©r√©-en-liste) sur la conversion des types de valeurs (ou *"casting"*).

Sauf que cette fois-ci, il faudra faire l'inverse, √† savoir que la conversion ne sera plus *bytearray* -> *list* mais *list* -> *bytearray*.
:::


### 6 ¬∑ Ouverture d'un nouveau fichier image corrompu en mode √©criture binaire

üëâ Ouvrez un nouveau fichier qui recevra le contenu des nouvelles donn√©es corrompues de notre image.

:::{tip}
(Re)voir le tip du [(1)](#1--ouvrir-le-fichier) expliquant comment ouvrir et manipuler un ficher avec la fonction `open()`, en utilisant cette fois-ci le mode `wb` (`w` = *write* et `b` = *binaire*).
:::

:::{warning} 
Attention, `open` en mode `w` cr√©era le fichier s'il n'existe pas et üö® l'**√âCRASERA üö® SANS üö® SOMMATION** üö® s'il existe d√©j√† (par un fichier totalement vide dans un premier temps).

Faites donc bien gaffe au chemin du fichier que vous mettez en param√®tre du coup, √©vitez que cela soit une DLL system32 notamment
:::


### 7 ¬∑ Ecrire le contenu du nouveau fichier

üëâ √âcrire le nouveau fichier avec les nouvelles donn√©es alt√©r√©es, que nous avons reconverti en bytearray √† l'√©tape [(5)](#5--retransformation-de-la-liste-en-bytearray).

:::{admonition} √âcriture dans un fichier
:class: tip, dropdown
Vous pouvez √©crire dans un fichier **ouvert en mode √©criture** en utilisant la m√©thode `.write()` de l'objet retourn√© par la fonction `open` ayant servi √† ouvrir le fichier.

Cette m√©thode prend un unique param√®tre correpondant aux donn√©es √† inscrire dans le fichier.

```python
fichier.write(nouveau_contenu_du_fichier_brut)
```
:::

:::{warning}
Ne pas oublier de fermer le fichier d√®s que vous avez termin√© de travailler avec ! (voir le tip en [(2b)](#2--lire-et-r√©cup√©rer-le-contenu-du-fichier))
:::

### Conclusion partie 2

Vous devriez avoir une belle image comprenant, avec un peu de chance, quelques glitchs mineurs! Non ? Alors relancez-le...

√áa ne fait toujours rien ? Et bien cela signifie qu'il va falloir taper [PÃ∏ÕÑÃøÕåÕíÃéÃñÃ≠Ã§ÃπÕúÃ¢Ã≥ÃñÃ≥Ã¢ÕÖÃ•ÃπÃñLÃ∏ÃèÕåÃåÃèÃáÃ™Ã£Ã≠ÃûÃùÃ•Ã°ÃÆÃ∫ÕîÃ∞ÕöÃ£ÕúÃ†UÃ∏ÃøÕùÃÄÃêÃßÃ´ÕâÕôÕôSÃ∏ÃáÃìÃÑÕâÃ∫Ã¶ÕàÃÆÕáÃòÃ≤ÃØÃ±ÕúÕöÕç ÃµÕòÃâÕÅÃõÕòÕíÃêÃøÃ≤ÕéFÃµÃÑÃáÃêÃçÕïOÃµÕÜÃöÕóÃÇÃÑÕÑÃáÃåÕ†ÃøÃöÃÉÃ∫Ã¢Ã§Ã¢RÃ∂Õ†ÃêÃÜÕÄÕàÕïÃØÃØÃ¢ÕîÃ¢ÕïÃßÕâÃÆÃ£Ã†Ã®Ã†TÃ¥ÃîÃÑÕàÃ©ÃûÃ°ÃúÕçÕì](#partie-3).


## PARTIE 3

Ok alors il va probablement falloir beaucoup d'essais pour obtenir le moindre glitch. Corrompre un octet dans l'ensemble d'un JPEG pouvant en contenir des millions... Ca ne sera probablement pas suffisant pour avoir un effet visible.

Du coup... On va multiplier la destruction :<


### 1 ¬∑ R√©p√©ter la corruption

üëâ Mettez toute la partie du code de la partie 2 qui injecte les mauvaises informations dans une boucle `for ... in range(...)`, afin de faire en sorte que ce code aille corrompre √† r√©p√©tition diff√©rents endroits al√©atoires de notre fichier.

:::{tip}
S'il y a toujours aussi peu de corruption alors que votre code se r√©p√®te bel et bien, faites bien attention √† ce que vous faites boucler ! Peut-√™tre que trop choses ont √©t√© incluse dans le bloc de code.

Par exemple, si vous lisez le fichier avec `.read()` √† chaque it√©ration de la boucle, cela sera comme si vous recommenciez le processus de corruption du d√©but, √† chaque it√©ration de la boucle, car cela correspond √† repartir d'un fichier sain, plut√¥t que multiplier les couches de corruption sur les m√™mes donn√©es que vous avez lu depuis le fichier.
:::

Les destructions sont assez visibles ? Peut-√™tre trop ? Ajustez le nombre d'it√©rations de la boucle, pour faire p√©ter plus ou moins d'octets, en fonction de l'effet d√©sir√©, ou si l'op√©ration rend le fichier illisible.

D√®s que c'est bon, on va animer tout √ßa !


### 2 ¬∑ G√©n√©ration d'une s√©rie d'images glitch√©es

Maintenant que l'on a une belle image glitch√©e, on peut tr√®s facilement en faire une s√©rie !


#### 2a ¬∑ Boucle `for` pour g√©n√©rer plein d'images

üëâ Faites une nouvelle boucle `for i in range(...)` qui ENGLOBE l'ensemble de la boucle que vous avez d√©fini en [(1a)](#1--r√©p√©ter-la-corruption), et qui fera donc r√©p√©ter **l'ensemble de l'op√©ration de destruction de l'image, de l'ouverture du fichier original √† l'√©criture de l'image corrompue**.

Le but de cette boucle sera de g√©n√©rer un certain nombre de versions glitch√©es de notre fichier image originale. Ce n'est pas grave si dans un premier temps, elle √©crase toujours le m√™me fichier image, on verra comment nommer nos diff√©rentes frames dans la partie suivante.


#### 2b ¬∑ G√©n√©rer un nom unique et num√©rot√© pour chaque frame √† g√©n√©rer

Chacune de ces images sera num√©rot√©e avec un num√©ro d'image *padded*.

:::{admonition} C'est quoi le padding?
:class: note

*to pad* signifie *remplir*, et implique ici l'action de venir ajouter un certain nombre de caract√®res √† une chaine de caract√®res afin que cette chaine fasse AU MOINS une certaine taille.

Dans le cas pr√©sent, on va vouloir ajouter autant de `0` qu'il faudra, √† gauche de notre nombre, afin d'avoir toujours au moins 3 chiffres dans notre cha√Æne de caract√®res.

Par exemple :
* `4`-> `004`
* `23`-> `023`
* `420`-> `420`
:::


Ces noms seront d√©finis en fonction d'un compteur que l'on incr√©mentera de fichier en fichier, et qui ressembleront donc √† :

* `Glitch_001.jpg` pour le premier fichier de la liste
* `Glitch_002.jpg` pour le deuxi√®me, etc...

üëâ Pour cela, nous allons **cr√©er une nouvelle variable**, dans laquelle nous concat√©nerons :
* le pr√©fixe de notre fichier (`"Glitch_"`)
* le num√©ro de frame avec padding (voir ci-dessous) (`001`, `002`...)
* l'extension (`.JPG` donc).

:::{admonition} Padding d'une chaine de caract√®re (aka "faire une belle num√©rotation")
:class: tip, dropdown
Pour obtenir un nombre avec un "**padding**", on utilisera la m√©thode `.zfill()`, directement int√©gr√©e aux valeurs de type chaine de caract√®res.

```python
str(9).zfill(3) # Ceci renverra -> 009 :)
```

Petite explication sur cette ligne :
* on convertit le nombre `9` au format chaine de caract√®re (*string*),
* puis on utilise la m√©thode `zfill` int√©gr√©e au type `string` pour ajouter le nombre de `0` devant le nombre pour que la taille¬†de la chaine de caract√®res finale corresponde AU MOINS √† la valeur renseign√©e en param√®tres de `zfill`.
* cette m√©thode est disponible sur chaque variable de type cha√Æne de caract√®re. Par exemple : `"9".zfill(3)` c'est valide

Exemples d'utilisations de `zfill` :
```python
"12".zfill(6) ¬† ¬†# Retournera "000012"
```
```python
"9754".zfill(3) ¬†# Retournera "9754"
```
```python
"8".zfill(2) ¬† ¬† # Retournera "08"
```
```python
nombre_en_string = "23"
nombre_en_string_avec_padding = nombre_en_string.zfill(5)
print(nombre_en_string_avec_padding)  # Affichera "00023"
```
:::


### 3 ¬∑ D√©tecter et recommencer les images illisibles

Il y a un tr√®s fort risque que certaines images que nous allons g√©n√©rer soient illisibles. Puisque l'on tape au hasard dans le fichier, il est possible que nous supprimions trop d'information, ou bien des informations primordiales au d√©codage du fichier (certaines m√©tadonn√©es de l'en-t√™te du JPG notamment).

On va donc v√©rifier, apr√®s l'√©criture de chaque image, que celle-ci est bel et bien lisible. Et si c'est le cas, on recommencera toute la s√©quence de corruption une nouvelle fois, du d√©but, pour g√©n√©rer la m√™me frame.

#### 3a ¬∑ Installer la librarie `pillow`

üëâ Pour cela, nous allons faire appel au module de manipulation d'images `pillow`, qu'il faudra installer via le gestionnaire de modules `pip` (‚ÑπÔ∏è Voir [la partie du support cours √† ce sujet](./cours.md#t√©l√©charger-de-nouveaux-modules)).

#### 3b ¬∑ La fonction `isImageValid()`

üëâ Copiez-collez la fonction ci-dessous tout en haut de votre script :

```python
from PIL import Image

def isImageValid(path):
	try:
		imageFile = Image.open(path)
		imageFile.save(path)
		return True
	
	except:
		return False
```
  
Cette fonction prend le chemin d'une image en param√®tre, et retourne `True` si l'image est valide et `False` sinon.

Elle tente d'ouvrir l'image avec la librairie de manipulation d'image PIL, qui crashera √† la sauvegarde (car c'est le moment o√π la libraire essaie de d√©coder l'image) si elle n'est pas valide.
Le crash est attrap√© par l'instruction de gestion d'erreur `try ... catch` (que nous n'avons pas encore abord√©), qui fera en sorte que la fonction retourne `False` si un tel √©v√®nement se produisait.

Oui, c'est un peu bourrin. Mais √ßa fonctionne √† tous les coups.

#### 3c ¬∑ Recommencer la g√©n√©ration si l'image est invalide

Utilisez la fonction `isImageValid()` afin de v√©rifier si l'image que l'on vient de g√©n√©rer est valide.

Si ce n'est pas le cas, c'est-√†-dire si la fonction renvoie `False`, alors on reg√©n√©rera un nouveau fichier glitch√©, jusqu'√† ce que la frame soit lisible.

:::{admonition} INDICE
:class: tip, dropdown
L'utilisation d'une boucle `while` prendra tout son sens pour r√©gler cette probl√©matique !

En effet, on souhaite ici qu'un bloc de code (ici la partie du programme g√©n√©rant une frame en particulier) s'ex√©cute jusqu'√† ce qu'une condition soit remplie (la validit√© d'une image).

Ce qui d√©crit parfaitement une probl√©matique √† laquelle peut r√©pondre une boucle `while` :)
:::


### 4 ¬∑ Encoder la s√©quence d'image en vid√©o

Une fois la s√©quence d'images g√©n√©r√©e, encodez-l√† en MP4 avec `ffmpeg` !
De nouveau, n'h√©sitez pas √† consulter le [[TD3#6 ¬∑ Encodage de la vid√©o|TD sur le timelapse]] pour cette √©tape.